<html>
  <head>
    <title>Lift moar</title>
    <style>
.hide {
  display: none;
}
    </style>
    <script src="/session.js"></script>
    <script>window.ship = window.ship || "zod";</script>
  </head>
  <body>
    <div class="header">
      <a href="#">track</a>
      <a href="#plan">plan</a>
      <a href="#history">history</a>
      <a href="#share">share</a>
      <a href="#settings">settings</a>
    </div>
    <div id="app">
      <div class="page loading">
        Loading...
      </div>
      <div class="page hide start-workout">
        <button class="start-planned-workout">Start planned workout</button>
        <button class="start-freeform-workout">Start freeform workout</button>
      </div>
      <div class="page hide ongoing-workout">
        <div>current workout started at <span></span></div>
        <button class="add-new-lift-to-workout">+ add</button>
        <ul class="lifts-in-current-workout"></ul>
      </div>
      <div class="page hide history">
        Workouts:
        <ul class="workouts-list"></ul>
      </div>
    </div>
    <script>!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).UrbitHttpApi={})}(this,(function(e){"use strict";class t extends Error{}class n extends Error{}var s={};Object.defineProperty(s,"__esModule",{value:!0});var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i="undefined"!=typeof window&&void 0!==window.document,r="object"===("undefined"==typeof self?"undefined":o(self))&&self.constructor&&"DedicatedWorkerGlobalScope"===self.constructor.name,a="undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node,c=s.isBrowser=i;function d(e){let t,n,s,o=!1;return function(i){void 0===t?(t=i,n=0,s=-1):t=function(e,t){const n=new Uint8Array(e.length+t.length);return n.set(e),n.set(t,e.length),n}(t,i);const r=t.length;let a=0;for(;n<r;){o&&(10===t[n]&&(a=++n),o=!1);let i=-1;for(;n<r&&-1===i;++n)switch(t[n]){case 58:-1===s&&(s=n-a);break;case 13:o=!0;case 10:i=n}if(-1===i)break;e(t.subarray(a,i),s),a=n,s=-1}a===r?t=void 0:0!==a&&(t=t.subarray(a),n-=a)}}s.isWebWorker=r,s.isNode=a,s.isJsDom=function(){return"undefined"!=typeof window&&"nodejs"===window.name||navigator.userAgent.includes("Node.js")||navigator.userAgent.includes("jsdom")};var l=function(e,t){var n={};for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&t.indexOf(s)<0&&(n[s]=e[s]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(s=Object.getOwnPropertySymbols(e);o<s.length;o++)t.indexOf(s[o])<0&&Object.prototype.propertyIsEnumerable.call(e,s[o])&&(n[s[o]]=e[s[o]])}return n};const h="text/event-stream",u="last-event-id";function p(e,t){var{signal:n,headers:s,onopen:o,onmessage:i,onclose:r,onerror:a,openWhenHidden:c,fetch:p}=t,b=l(t,["signal","headers","onopen","onmessage","onclose","onerror","openWhenHidden","fetch"]);return new Promise(((t,l)=>{const g=Object.assign({},s);let w;function v(){w.abort(),document.hidden||O()}g.accept||(g.accept=h),c||document.addEventListener("visibilitychange",v);let y=1e3,m=0;function k(){document.removeEventListener("visibilitychange",v),window.clearTimeout(m),w.abort()}null==n||n.addEventListener("abort",(()=>{k(),t()}));const S=null!=p?p:window.fetch,E=null!=o?o:f;async function O(){var n;w=new AbortController;try{const n=await S(e,Object.assign(Object.assign({},b),{headers:g,signal:w.signal}));await E(n),await async function(e,t){const n=e.getReader();let s;for(;!(s=await n.read()).done;)t(s.value)}(n.body,d(function(e,t,n){let s={data:"",event:"",id:"",retry:void 0};const o=new TextDecoder;return function(i,r){if(0===i.length)null==n||n(s),s={data:"",event:"",id:"",retry:void 0};else if(r>0){const n=o.decode(i.subarray(0,r)),a=r+(32===i[r+1]?2:1),c=o.decode(i.subarray(a));switch(n){case"data":s.data=s.data?s.data+"\n"+c:c;break;case"event":s.event=c;break;case"id":e(s.id=c);break;case"retry":const n=parseInt(c,10);isNaN(n)||t(s.retry=n)}}}}((e=>{e?g[u]=e:delete g[u]}),(e=>{y=e}),i))),null==r||r(),k(),t()}catch(e){if(!w.signal.aborted)try{const t=null!==(n=null==a?void 0:a(e))&&void 0!==n?n:y;window.clearTimeout(m),m=window.setTimeout(O,t)}catch(e){k(),l(e)}}}O()}))}function f(e){const t=e.headers.get("content-type");if(!(null==t?void 0:t.startsWith(h)))throw new Error(`Expected content-type to be text/event-stream, Actual: ${t}`)}function b(e){const t=Math.pow(16,Math.min(e,8)-1),n=Math.pow(16,Math.min(e,8))-1;let s=(Math.floor(Math.random()*(n-t+1))+t).toString(16);for(;s.length<e;)s+=b(e-8);return s}class g{constructor(e,t,n){return this.url=e,this.code=t,this.desk=n,this.uid=`${Math.floor(Date.now()/1e3)}-${b(6)}`,this.lastEventId=0,this.lastHeardEventId=-1,this.lastAcknowledgedEventId=-1,this.sseClientInitialized=!1,this.outstandingPokes=new Map,this.outstandingSubscriptions=new Map,this.abort=new AbortController,this.errorCount=0,this.onError=null,this.onRetry=null,this.onOpen=null,c&&window.addEventListener("beforeunload",this.delete),this}get channelUrl(){return`${this.url}/~/channel/${this.uid}`}get fetchOptions(){const e={"Content-Type":"application/json"};return c||(e.Cookie=this.cookie),{credentials:"include",accept:"*",headers:e,signal:this.abort.signal}}static async authenticate({ship:e,url:t,code:n,verbose:s=!1}){const o=new g(t.startsWith("http")?t:`http://${t}`,n);return o.verbose=s,o.ship=e,await o.connect(),await o.poke({app:"hood",mark:"helm-hi",json:"opening airlock"}),await o.eventSource(),o}async connect(){return this.verbose&&console.log(`password=${this.code} `,c?`Connecting in browser context at ${this.url}/~/login`:"Connecting from node context"),fetch(`${this.url}/~/login`,{method:"post",body:`password=${this.code}`,credentials:"include"}).then((e=>{this.verbose&&console.log("Received authentication response",e);const t=e.headers.get("set-cookie");this.ship||(this.ship=new RegExp(/urbauth-~([\w-]+)/).exec(t)[1]),c||(this.cookie=t)}))}async eventSource(){return this.sseClientInitialized?Promise.resolve():0!==this.lastEventId?(this.sseClientInitialized=!0,new Promise(((e,t)=>{p(this.channelUrl,{...this.fetchOptions,openWhenHidden:!0,onopen:async n=>{if(this.verbose&&console.log("Opened eventsource",n),n.ok)return this.errorCount=0,this.onOpen&&this.onOpen(),void e();{const e=new Error("failed to open eventsource");t(e)}},onmessage:e=>{if(this.verbose&&console.log("Received SSE: ",e),!e.id)return;const t=parseInt(e.id,10);if(t<=this.lastHeardEventId)console.log("dropping old or out-of-order event",{eventId:t,lastHeard:this.lastHeardEventId});else if(this.lastHeardEventId=t,t-this.lastAcknowledgedEventId>20&&this.ack(t),e.data&&JSON.parse(e.data)){const t=JSON.parse(e.data);if("poke"===t.response&&this.outstandingPokes.has(t.id)){const e=this.outstandingPokes.get(t.id);t.hasOwnProperty("ok")?e.onSuccess():t.hasOwnProperty("err")?(console.error(t.err),e.onError(t.err)):console.error("Invalid poke response",t),this.outstandingPokes.delete(t.id)}else if("subscribe"===t.response&&this.outstandingSubscriptions.has(t.id)){const e=this.outstandingSubscriptions.get(t.id);t.hasOwnProperty("err")&&(console.error(t.err),e.err(t.err,t.id),this.outstandingSubscriptions.delete(t.id))}else if("diff"===t.response&&this.outstandingSubscriptions.has(t.id)){const e=this.outstandingSubscriptions.get(t.id);try{e.event(t.json,t.mark??"json")}catch(e){console.error("Failed to call subscription event callback",e)}}else if("quit"===t.response&&this.outstandingSubscriptions.has(t.id)){this.outstandingSubscriptions.get(t.id).quit(t),this.outstandingSubscriptions.delete(t.id)}else console.log([...this.outstandingSubscriptions.keys()]),console.log("Unrecognized response",t)}},onerror:e=>{if(console.warn(e),!(e instanceof n)&&this.errorCount++<4)return this.onRetry&&this.onRetry(),750*Math.pow(2,this.errorCount-1);throw this.onError&&this.onError(e),e},onclose:()=>{throw console.log("e"),new Error("Ship unexpectedly closed the connection")}})}))):void await this.poke({app:"hood",mark:"helm-hi",json:"Opening API channel"})}reset(){this.verbose&&console.log("resetting"),this.delete(),this.abort.abort(),this.abort=new AbortController,this.uid=`${Math.floor(Date.now()/1e3)}-${b(6)}`,this.lastEventId=0,this.lastHeardEventId=-1,this.lastAcknowledgedEventId=-1,this.outstandingSubscriptions=new Map,this.outstandingPokes=new Map,this.sseClientInitialized=!1}getEventId(){return++this.lastEventId}async ack(e){this.lastAcknowledgedEventId=e;const t={action:"ack","event-id":e};return await this.sendJSONtoChannel(t),e}async sendJSONtoChannel(...e){if(!(await fetch(this.channelUrl,{...this.fetchOptions,method:"PUT",body:JSON.stringify(e)})).ok)throw new Error("Failed to PUT channel");this.sseClientInitialized||await this.eventSource()}async subscribeOnce(e,t,n){return new Promise((async(s,o)=>{let i=!1,r=null;const a={app:e,path:t,event:e=>{i||(s(e),this.unsubscribe(r))},err:o,quit:()=>{i||o("quit")}};r=await this.subscribe(a),n&&setTimeout((()=>{i||(i=!0,o("timeout"),this.unsubscribe(r))}),n)}))}async poke(e){const{app:t,mark:n,json:s,ship:o,onSuccess:i,onError:r}={onSuccess:()=>{},onError:()=>{},ship:this.ship,...e},a={id:this.getEventId(),action:"poke",ship:o,app:t,mark:n,json:s},[c,d]=await Promise.all([this.sendJSONtoChannel(a),new Promise(((e,t)=>{this.outstandingPokes.set(a.id,{onSuccess:()=>{i(),e(a.id)},onError:e=>{r(e),t(e.err)}})}))]);return d}async subscribe(e){const{app:t,path:n,ship:s,err:o,event:i,quit:r}={err:()=>{},event:()=>{},quit:()=>{},ship:this.ship,...e},a={id:this.getEventId(),action:"subscribe",ship:s,app:t,path:n};return this.outstandingSubscriptions.set(a.id,{app:t,path:n,err:o,event:i,quit:r}),await this.sendJSONtoChannel(a),a.id}async unsubscribe(e){return this.sendJSONtoChannel({id:this.getEventId(),action:"unsubscribe",subscription:e}).then((()=>{this.outstandingSubscriptions.delete(e)}))}delete(){c&&navigator.sendBeacon(this.channelUrl,JSON.stringify([{action:"delete"}]))}async scry(e){const{app:t,path:n}=e,s=await fetch(`${this.url}/~/scry/${t}${n}.json`,this.fetchOptions);return s.ok?await s.json():Promise.reject(s)}async thread(e){const{inputMark:t,outputMark:n,threadName:s,body:o,desk:i=this.desk}=e;if(!i)throw new Error("Must supply desk to run thread from");return(await fetch(`${this.url}/spider/${i}/${t}/${s}/${n}.json`,{...this.fetchOptions,method:"POST",body:JSON.stringify(o)})).json()}static async onArvoNetwork(e,t){const n=`https://${e}.arvo.network`;return await g.authenticate({ship:e,url:n,code:t})}}e.FatalError=n,e.ResumableError=t,e.Urbit=g,e.default=g}));

</script>
    <script>const NULL_DATE = 946684800000;
const api = new UrbitHttpApi.Urbit("", "", "lift");
api.ship = window.ship;
async function getAgentState() {
  var h = await api.scry({app: "lift", path: "/history"});
  State.history = h.map( w => ({
    lifts: w.lifts,
    start: new Date(w.start),
    end: w.end === NULL_DATE ? null : new Date(w.end)
  }))
  var es = await api.scry({app: "lift", path: "/exercises"});
  State.exercises = {};

  es.map(e => {
    e.id = ""+e.id.num + e.id.ship;
    return e;
  }).forEach(e => {
    State.exercises[e.id] = e;
  })
}
let State = {page: "root", history: [], exercises: [], plans: []};
const setState = (key, val) => {
  console.log('setting state');
  State[key] = val;
  const stateChangedEvent = new CustomEvent("statechanged", {detail:{ key, val }});
  window.dispatchEvent(stateChangedEvent);
}; 
function startNewWorkout() {
  api.poke({
    app: 'lift',
    mark: 'lift-action',
    json: {
      "start-workout": "~"+api.ship,
    },
  }).then(r=>{
    console.log('r',r);
  })
  // TODO call to urbit, get response of new workout object
  State.history.push({
    lifts: [],
    start: new Date(),
    end: null
  })
}
const Renderers = {
  "root" : () => {
    // if there is a workout ongoing
    if (State.history.length > 0 && State.history[0].end === null) {
      setState('page', "ongoing-workout");
    } else {
      const page = document.querySelector(".page.start-workout");
      page.classList.toggle("hide", false);
      page.querySelector(".start-planned-workout").classList.toggle("hide", State.plans.length == 0);
    }
  },
  "ongoing-workout" : () => {
    // if there is not a workout ongoing go to start-workout page
    if (State.history.length === 0 || State.history[0].end !== null) {
      setState('page', "root");
      return;
    }

    const page = document.querySelector(".page.ongoing-workout");
    page.classList.toggle("hide", false);
    const workout = State.history[0];
    page.querySelector("span").innerHTML = workout.start.toLocaleTimeString();

    let listHTML = "";
    for (lift of workout.lifts) {
      const ex = State.exercises[lift.id];
      listHTML += "<li>"+ex.name+" <img width='100' src=\""+ex.img+"\"/></li>";
    }
    page.querySelector("ul.lifts-in-current-workout").innerHTML = listHTML;

  },
  "history" : () => {
    const page = document.querySelector(".page.history");
    page.classList.toggle("hide", false);

    let listHTML = "";
    for (workout of State.history) {
      listHTML += "<li>"+(workout.start.toDateString())+"</li>";
    }
    page.querySelector("ul.workouts-list").innerHTML = listHTML;

  },
};

const setup = [
  // setup start-workout page
  function() {
    const freeformBtn = document.querySelector(".page.start-workout button.start-freeform-workout");
    freeformBtn.addEventListener('click', (event) => {
      event.preventDefault();
      startNewWorkout();
      setState('page', "ongoing-workout");
    });
  },
  // setup ongoing-workout page
  function() {
    const btn = document.querySelector(".page.ongoing-workout button.add-new-lift-to-workout");
    btn.addEventListener('click', (event) => {
      event.preventDefault();
      // TODO tell urbit about this
      State.history[0].lifts.push({id: 1, sets: [], details: {}});
      render("ongoing-workout");
    });
  }
];

function render(path) {
  if (Renderers[path]) {
    Array.from(document.getElementsByClassName("page")).forEach(page => {
      page.classList.toggle('hide', true);
    })
    Renderers[path]();
  }
}

document.addEventListener("DOMContentLoaded", () => {
  getAgentState();

  render(State.page);
  window.addEventListener('statechanged', (event) => {
    console.log(event);
    if (event.detail.key === 'page') {
      render(event.detail.val);
    }
  });

  for (fn of setup) {
    fn();
  }
});

/*
function parseTemplates() {
  let templates = {};
  const container = document.getElementById("templates");
  for (child of container.children) {
    const name = child.id.substr(9);
    templates[name] = child;
  }
  return templates;
}

function updateToMatchPath(templates) {
  const path = window.location.hash.substr(1);
  if (templates[path]) {
    let raw = templates[path].innerHTML;
    // handle calls to other templates
    const matches = raw.match(/\{\{\s*([a-z\-]+)\s*\}\}/gi);
    for (match of matches) {
      const calledTemplateName = match.replace(/\{\{\s* ?/, "").replace(/\s*\}\}/, "");
      if (templates[calledTemplateName]) {
        raw = raw.replace(match, templates[calledTemplateName].innerHTML);
      }
    }
    document.getElementById("app").innerHTML = raw;
  }
}*/
</script>
  </body>
</html>
